<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Alias CBU ‚Äì Gasless AIC</title>
  <style>
    body { font-family: system-ui, sans-serif; max-width: 840px; margin: 2rem auto; padding: 0 1rem; background: #fafafa; }
    label { display:block; margin-top: 1rem; font-weight: 600; }
    input, button { padding: .6rem .8rem; font-size: 1rem; }
    button { cursor:pointer; border-radius: 6px; border: 1px solid #ccc; background: white; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap: wrap; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 0.9em; }
    .card { border:1px solid #ddd; border-radius: 10px; padding: 1rem; margin-top:1rem; background: white; }
    .ok { color:#0a0; font-weight: 600; } 
    .err { color:#a00; font-weight: 600; } 
    .warn { color:#f80; font-weight: 600; }
    .muted { color:#666; font-size:.9rem }
    .alert { background: #fff3cd; border: 1px solid #ffc107; padding: 1rem; border-radius: 8px; margin: 1rem 0; }
    .alert-danger { background: #f8d7da; border-color: #f5c6cb; }
    pre { background: #f5f5f5; padding: 0.5rem; border-radius: 4px; overflow-x: auto; }
    #wallet-ok { margin-top: .5rem; color: #086; font-weight: 600; }
    #wallet-error { margin-top: .5rem; color: #c00; }
  </style>
</head>
<body>
  <h1>Registrar alias (gasless, paga en AIC)</h1>
 
  <p class="muted">
    1) Conect√° wallet ¬∑ 2) Prepar√° ¬∑ 3) Approve AIC ¬∑ 4) Firmar ¬∑ 5) Enviar<br/>
    <small>Si el approve falla, us√° Firefox o actualiz√° la extensi√≥n.</small>
  </p>

  <div class="card">
    <div class="row">
      <button id="btn-connect">Conectar Wallet</button>
      <button id="btn-reset" type="button">Reset</button>
      <span id="acc" class="mono"></span>
    </div>

    <label for="alias">Alias (a-z 0-9 .) 4‚Äì20</label>
    <input id="alias" placeholder="mi.alias" style="width:100%; font-family: monospace;"/>

    <div class="card" style="background:#f9fbff; margin-top:1rem;">
      <strong>Direcciones externas (opcional)</strong>
      <p class="muted" style="margin-top:.5rem;">
        Se convierten a <code>felt</code>. Ingres√° valores en hex <code>0x‚Ä¶</code> o texto ASCII (‚â§31 bytes).
      </p>
      <label for="eth-address" style="margin-top:.5rem;">ETH (0x‚Ä¶)</label>
      <input id="eth-address" placeholder="0x1234‚Ä¶" style="width:100%; font-family: monospace;"/>
      <label for="btc-address" style="margin-top:.5rem;">BTC / identificador</label>
      <input id="btc-address" placeholder="btc1‚Ä¶ / hash" style="width:100%; font-family: monospace;"/>
    </div>

    <div class="row" style="margin-top: .5rem;">
      <button id="btn-prepare" disabled>1. Preparar</button>
      <button id="btn-approve" disabled>2. Approve AIC</button>
      <button id="btn-sign" disabled>3. Firmar</button>
      <button id="btn-submit" disabled>4. Enviar</button>
    </div>

    <div id="prep" class="mono" style="white-space:pre-wrap; margin-top:1rem; font-size: 0.85em;"></div>
    <div id="out" style="margin-top:1rem;"></div>
  </div>

  <div class="card">
    <h3>Buscar / Resolver</h3>
    <div class="row">
      <input id="q-alias" placeholder="alias (p.ej. pepe.123)" style="flex:1; font-family:monospace;">
      <button id="btn-resolve-alias">Alias ‚Üí Address</button>
    </div>
    <div class="row" style="margin-top:.5rem;">
      <input id="q-addr" placeholder="0x..." style="flex:1; font-family:monospace;">
      <button id="btn-resolve-addr">Address ‚Üí Alias</button>
    </div>
    <div class="row" style="margin-top:.5rem;">
      <select id="chain-select" style="flex:0 0 160px;">
        <option value="ETH">ETH</option>
        <option value="BTC">BTC</option>
      </select>
      <input id="external-address" placeholder="externo (0x‚Ä¶ o ASCII)" style="flex:1; font-family:monospace;">
      <button id="btn-resolve-external">Ext ‚Üí Alias</button>
    </div>
    <div class="row" style="margin-top:.5rem;">
      <button id="btn-list">Listar (√≠ndice local del relayer)</button>
    </div>
    <div class="row" style="margin-top:.5rem;">
  <button id="btn-faucet" style="background:#0a0; color:#fff;">üö∞ Faucet AIC</button>
</div>

    <pre id="resolve-out" class="mono" style="margin-top: .5rem;"></pre>
  </div>

  <div id="wallet-ok"></div>
  <div id="wallet-error"></div>

  <!-- API_BASE vac√≠o = MISMO dominio (Vercel sirve app.py en /api/*) -->
  <script>
    const API_BASE = ""; 
    const apiUrl = (path) => {
      const base = API_BASE ? API_BASE.replace(/\/$/, "") : "";
      return `${base}${path}`;
    };
  </script>

  <script>
  (function () {
    const $ = id => document.getElementById(id);
    const okEl = $("wallet-ok");
    const errEl = $("wallet-error");
    const ethInputEl = $("eth-address");
    const btcInputEl = $("btc-address");
    const chainSelect = $("chain-select");
    const externalAddressInput = $("external-address");

    function shortHex(h){ if(!h) return ""; const s=h.replace(/^0x/,""); return "0x"+s.slice(0,6)+"‚Ä¶"+s.slice(-6); }
    function showError(msg){ console.error(msg); errEl && (errEl.textContent = msg); alert(msg); }
    function log(m, type = 'info') {
      const icons = { info: '‚ÑπÔ∏è', ok: '‚úÖ', err: '‚ùå', warn: '‚ö†Ô∏è' };
      const classes = { info: '', ok: 'ok', err: 'err', warn: 'warn' };
      console.log("[aliascbu]", m);
      $("out").innerHTML = `<span class="${classes[type]}">${icons[type]} ${
        typeof m === "string" ? m.replace(/\n/g, '<br/>') : JSON.stringify(m, null, 2)
      }</span>`;
    }

    // ===== Utils Cairo/hex =====
    const FIELD_P = (2n ** 251n) + (17n * (2n ** 192n)) + 1n;
    const strip0x = (h) => (h || "").toLowerCase().replace(/^0x/, "");
    const padHex64 = (h) => "0x" + strip0x(h).padStart(64, "0");
    const toFeltHex = (hex) => {
      let n = BigInt("0x" + strip0x(hex));
      n = ((n % FIELD_P) + FIELD_P) % FIELD_P;
      return "0x" + n.toString(16);
    };
    const toUint256 = (value) => {
      const bn = BigInt(value);
      return {
        low: "0x" + (bn & ((1n << 128n) - 1n)).toString(16),
        high: "0x" + (bn >> 128n).toString(16)
      };
    };

    function buildTypedData(alias_key_hex, len, user_hex, nonce, chainId_hex, eth_felt, btc_felt) {
      const cleanHex = (h) => {
        const s = strip0x(h);
        return "0x" + (s.replace(/^0+/, "") || "0");
      };
      return {
        types: {
          StarkNetDomain: [
            { name: "name", type: "felt" },
            { name: "version", type: "felt" },
            { name: "chainId", type: "felt" },
          ],
          RegisterAlias: [
            { name: "user_addr", type: "felt" },
            { name: "alias_key", type: "felt" },
            { name: "len", type: "felt" },
            { name: "nonce", type: "felt" },
            { name: "eth_address", type: "felt" },
            { name: "btc_address", type: "felt" },
          ],
        },
        primaryType: "RegisterAlias",
        domain: {
          name: "AliasCBU",
          version: "1",
          chainId: cleanHex(chainId_hex),
        },
        message: {
          user_addr: toFeltHex(user_hex),
          alias_key: toFeltHex(alias_key_hex),
          len: String(len),
          nonce: String(nonce),
          eth_address: toFeltHex(eth_felt || "0x0"),
          btc_address: toFeltHex(btc_felt || "0x0"),
        },
      };
    }

    function detectXverse() {
      const guesses = [];
      if (window.starknet_xverse) guesses.push(window.starknet_xverse);
      const providers = window.xverseProviders;
      if (providers?.starknet) guesses.push(providers.starknet);
      if (window.xverse) {
        if (window.xverse.starknet) guesses.push(window.xverse.starknet);
        if (window.xverse.starknetProvider) guesses.push(window.xverse.starknetProvider);
      }
      if (window.xverseProvider) guesses.push(window.xverseProvider);
      if (window.xverseWallet?.starknet) guesses.push(window.xverseWallet.starknet);
      if (window.btc?.starknet) guesses.push(window.btc.starknet);
      for (const guess of guesses) {
        if (!guess) continue;
        if (typeof guess === "function") {
          try {
            const maybe = guess();
            if (maybe) return maybe;
          } catch (e) {}
        }
        if (typeof guess.getProvider === "function") {
          try {
            const provider = guess.getProvider();
            if (provider) return provider;
          } catch (e) {}
        }
        if (guess?.provider) return guess.provider;
        if (guess?.request || guess?.enable || guess?.account || guess?.selectedAddress || guess?.selectedAccount) {
          return guess;
        }
      }
      return null;
    }

    function waitForWallets(ms = 8000) {
      return new Promise((resolve) => {
        const kick = () => {
          const sn = window.starknet || null;
          const argentx = (sn && sn.isArgentX) ? sn : (window.starknet_argentX || null);
          const braavos = (sn && sn.isBraavos) ? sn : (window.starknet_braavos || window.braavos || null);
          const xverse = detectXverse();
          resolve({ braavos, argentx, xverse });
        };
        if (window.starknet || window.starknet_braavos || window.braavos || window.starknet_argentX || window.starknet_xverse || window.xverseProviders || window.xverse || window.xverseProvider || window.xverseWallet) return kick();
        const handler = () => kick();
        window.addEventListener('starknet#initialized', handler, { once: true });
        window.addEventListener('xverse#initialized', handler, { once: true });
        setTimeout(kick, ms);
      });
    }

    async function connectDirect() {
      const { braavos, argentx, xverse } = await waitForWallets(8000);
      const candidates = [
        { name: 'ArgentX', obj: argentx },
        { name: 'Braavos', obj: braavos },
        { name: 'Xverse', obj: xverse },
        { name: 'Braavos (legacy)', obj: window.braavos }
      ];
      for (const { name, obj } of candidates) {
        if (!obj) continue;
        try {
          if (typeof obj.enable === 'function') await obj.enable({ starknetVersion: 'v5' });
          else if (obj.request) await obj.request({ type: 'wallet_requestAccounts' });
          const acc = obj.account || obj.selectedAccount || obj;
          if (acc?.address) return { account: acc, address: acc.address, name };
          if (obj.selectedAddress) return { account: obj, address: obj.selectedAddress, name };
        } catch (e) {
          console.warn(`${name} fall√≥:`, e?.message || e);
        }
      }
      throw new Error("No se encontr√≥ ArgentX, Braavos ni Xverse. Revis√° 'Site access' en la extensi√≥n y recarg√°.");
    }

    let account = null, userAddr = null, prepared = null, cfg = null, walletName = null;

    function enableButtons(p, a, s, su) {
      $("btn-prepare").disabled = !p;
      $("btn-approve").disabled = !a;
      $("btn-sign").disabled = !s;
      $("btn-submit").disabled = !su;
    }

    async function getJSON(url) {
      const r = await fetch(url);
      const t = await r.text();
      let d = null;
      try { d = t ? JSON.parse(t) : null; } catch {}
      if (!r.ok) throw new Error(d?.detail || d?.error || t || `HTTP ${r.status}`);
      return d ?? {};
    }

    $("btn-connect").onclick = async () => {
      try {
        log("Conectando wallet...");
        const conn = await connectDirect();
        account = conn.account;
        userAddr = padHex64(conn.address);
        walletName = conn.name;
        $("acc").textContent = `${userAddr.slice(0,10)}...${userAddr.slice(-8)} (${conn.name})`;

        log("Obteniendo configuraci√≥n desde backend...", "info");
        const res = await fetch(apiUrl("/api/config"));
        if (!res.ok) throw new Error(await res.text());
        cfg = await res.json();

        cfg.external_chain_ids = cfg.external_chain_ids || {};
        cfg.aic_token = padHex64(cfg.aic_token);
        cfg.relayer_address = padHex64(cfg.relayer_address);
        cfg.chain_id = "0x" + strip0x(cfg.chain_id).replace(/^0+/, '');
        if (chainSelect) {
          chainSelect.innerHTML = "";
          const entries = Object.entries(cfg.external_chain_ids);
          if (!entries.length) {
            const opt = document.createElement("option");
            opt.value = "";
            opt.textContent = "Sin cadenas";
            chainSelect.appendChild(opt);
            chainSelect.disabled = true;
          } else {
            chainSelect.disabled = false;
            for (const [label, felt] of entries) {
              const opt = document.createElement("option");
              opt.value = label;
              opt.textContent = `${label} (${felt})`;
              chainSelect.appendChild(opt);
            }
          }
        }

        const chainLabels = Object.keys(cfg.external_chain_ids);
        log(`Conectado: ${conn.name}\nChainId: ${cfg.chain_id}\nChains externas: ${chainLabels.length ? chainLabels.join(', ') : 'ninguna'}`, 'ok');
        okEl && (okEl.textContent = `Conectado: ${shortHex(userAddr)} (${conn.name})`);
        enableButtons(true, false, false, false);
      } catch (e) {
        log(`Error: ${e.message}\n\nProb√°:\n‚Ä¢ Recargar (Ctrl+Shift+R)\n‚Ä¢ Usar Firefox\n‚Ä¢ Actualizar extensi√≥n`, 'err');
        showError(e.message);
      }
    };

    $("btn-reset").onclick = () => {
      account = userAddr = prepared = cfg = null;
      walletName = null;
      $("acc").textContent = "";
      $("prep").textContent = "";
      $("resolve-out").textContent = "";
      $("out").innerHTML = "";
      okEl && (okEl.textContent = "");
      errEl && (errEl.textContent = "");
      ethInputEl && (ethInputEl.value = "");
      btcInputEl && (btcInputEl.value = "");
      externalAddressInput && (externalAddressInput.value = "");
      if (chainSelect && chainSelect.options.length) {
        chainSelect.selectedIndex = 0;
      }
      enableButtons(false, false, false, false);
      log("Reset OK");
    };

    $("btn-prepare").onclick = async () => {
      if (!userAddr) { alert("Conect√° wallet"); return; }
      const alias = $("alias").value.trim();
      if (!alias) { alert("Ingres√° un alias"); return; }
      const ethRaw = ethInputEl ? ethInputEl.value.trim() : "";
      const btcRaw = btcInputEl ? btcInputEl.value.trim() : "";

      try {
        const res = await fetch(apiUrl("/api/prepare"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            user_address: userAddr,
            alias,
            eth_address: ethRaw || null,
            btc_address: btcRaw || null,
          })
        });
        if (!res.ok) throw new Error(await res.text());
        const data = await res.json();
        prepared = {
          ...data,
          alias_input: alias,
          eth_input: ethRaw,
          btc_input: btcRaw,
        };
        const lines = [
          `‚úì Alias: ${alias}`,
          `  Key: ${prepared.alias_key}`,
          `  Fee: ${prepared.fee_aic_wei} wei`,
        ];
        if (prepared.eth_address_felt && prepared.eth_address_felt !== "0x0") {
          const extra = prepared.eth_address_ascii ? ` (ascii: ${prepared.eth_address_ascii})` : "";
          lines.push(`  ETH felt: ${prepared.eth_address_felt}${extra}`);
        }
        if (prepared.btc_address_felt && prepared.btc_address_felt !== "0x0") {
          const extra = prepared.btc_address_ascii ? ` (ascii: ${prepared.btc_address_ascii})` : "";
          lines.push(`  BTC felt: ${prepared.btc_address_felt}${extra}`);
        }
        $("prep").textContent = lines.join("\n");
        log("Preparado OK. Ahora hac√© approve.", 'ok');
        enableButtons(true, true, false, false);
      } catch (e) {
        log("Error: " + (e.message || e), 'err');
      }
    };

    $("btn-approve").onclick = async () => {
      if (!prepared || !account) { alert("Falta preparar"); return; }
      try {
        const amount = toUint256(prepared.fee_aic_wei);
        const approveCall = {
          contractAddress: cfg.aic_token,
          entrypoint: "approve",
          calldata: [ cfg.relayer_address, amount.low, amount.high ]
        };
        const SAFE_MAX_FEE = "0x1DCD65000";
        const res = await account.execute([approveCall], undefined, {
          version: "0x3",
          maxFee: SAFE_MAX_FEE
        });
        const txHash = res.transaction_hash || res;
        log(`Approve enviado (v3 STRK)!\nTx: ${txHash}\nAhora firm√° el mensaje.`, "ok");
        enableButtons(true, true, true, false);
      } catch (e) {
        log(`Error approve: ${e.message || e}`, "err");
      }
    };

    async function signTypedMessageWithFallback(accountObj, typed) {
      try {
        let sig = await accountObj.signMessage(typed);
        if (!Array.isArray(sig) && sig?.r && sig?.s) sig = [sig.r, sig.s];
        return sig;
      } catch (e) {
        console.warn("signMessage est√°ndar fall√≥, probando request directa:", e);
      }
      if (walletName === 'Xverse') {
        const xverse = detectXverse();
        if (xverse?.request) {
          const payloads = [
            { type: "wallet_signTypedData", params: typed },
            { type: "wallet_signTypedData", params: [typed] },
            { type: "wallet_signMessage", params: typed },
            { type: "wallet_signMessage", params: [typed] },
          ];
          for (const payload of payloads) {
            try {
              let sig = await xverse.request(payload);
              if (sig?.result) sig = sig.result;
              if (!sig) continue;
              if (!Array.isArray(sig) && sig?.r && sig?.s) sig = [sig.r, sig.s];
              if (Array.isArray(sig)) return sig;
            } catch (_) {}
          }
        }
      }
      const br = window.starknet_braavos || window.braavos;
      if (br?.request) {
        let sig = await br.request({ type: "braavos_signMessage", params: typed });
        if (!Array.isArray(sig) && sig?.r && sig?.s) sig = [sig.r, sig.s];
        return sig;
      }
      throw new Error("No se pudo firmar el mensaje (wallet no respondi√≥).");
    }

    $("btn-sign").onclick = async () => {
      if (!prepared || !account) { alert("Falta preparar"); return; }
      try {
        const typed = buildTypedData(
          prepared.alias_key,
          prepared.len,
          userAddr,
          prepared.nonce,
          cfg.chain_id,
          prepared.eth_address_felt,
          prepared.btc_address_felt
        );
        const sig = await signTypedMessageWithFallback(account, typed);
        prepared.signature = sig;
        log(`Firma OK\nR: ${sig[0]}\nS: ${sig[1]}`, "ok");
        enableButtons(true, true, true, true);
      } catch (e) {
        log(`Error firmando: ${e.message || e}`, "err");
        enableButtons(true, true, true, false);
      }
    };

    $("btn-submit").onclick = async () => {
      if (!prepared?.signature) { alert("Falta firmar"); return; }
      try {
        log("Enviando al relayer...", 'info');
        const res = await fetch(apiUrl("/api/submit"), {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            user_address: userAddr,
            alias: prepared.alias_input || $("alias").value.trim(),
            signature: prepared.signature,
            nonce: prepared.nonce,
            eth_address: prepared.eth_address_felt,
            btc_address: prepared.btc_address_felt,
          })
        });
        if (!res.ok) throw new Error(await res.text());
        const out = await res.json();
        log(`‚úÖ REGISTRO EXITOSO!\n\nTx: ${out.tx_hash}\nRelayer: ${out.relayer}`, 'ok');
        prepared = null;
        $("prep").textContent = "";
        $("alias").value = "";
        ethInputEl && (ethInputEl.value = "");
        btcInputEl && (btcInputEl.value = "");
        enableButtons(true, false, false, false);
      } catch (e) {
        log(`Error: ${e.message}`, 'err');
      }
    };

    $("btn-resolve-alias").onclick = async () => {
      const alias = $("q-alias").value.trim();
      if (!alias) { alert("Ingres√° un alias"); return; }
      try {
        const r = await getJSON(apiUrl(`/api/resolve_alias?alias=${encodeURIComponent(alias)}`));
        $("resolve-out").textContent = JSON.stringify(r, null, 2);
      } catch (e) {
        $("resolve-out").textContent = "Error: " + (e.message || e);
      }
    };

    $("btn-resolve-addr").onclick = async () => {
      const addr = $("q-addr").value.trim();
      if (!addr) { alert("Ingres√° un address 0x"); return; }
      try {
        const r = await getJSON(apiUrl(`/api/resolve_address?address=${encodeURIComponent(addr)}`));
        $("resolve-out").textContent = JSON.stringify(r, null, 2);
      } catch (e) {
        $("resolve-out").textContent = "Error: " + (e.message || e);
      }
    };

    $("btn-resolve-external").onclick = async () => {
      const chain = chainSelect ? chainSelect.value : "";
      const ext = externalAddressInput ? externalAddressInput.value.trim() : "";
      if (!chain) { alert("Eleg√≠ una red externa"); return; }
      if (!ext) { alert("Ingres√° una direcci√≥n externa"); return; }
      try {
        const r = await getJSON(apiUrl(`/api/alias_of_external?chain=${encodeURIComponent(chain)}&external_address=${encodeURIComponent(ext)}`));
        $("resolve-out").textContent = JSON.stringify(r, null, 2);
      } catch (e) {
        $("resolve-out").textContent = "Error: " + (e.message || e);
      }
    };

    $("btn-list").onclick = async () => {
      try {
        const r = await getJSON(apiUrl("/api/list"));
        $("resolve-out").textContent = JSON.stringify(r, null, 2);
      } catch (e) {
        $("resolve-out").textContent = "Error: " + (e.message || e);
      }
    };

    $("btn-faucet").onclick = async () => {
  try {
    if (!userAddr) {
      alert("Conect√° la wallet primero");
      return;
    }
    const res = await fetch("/api/faucet", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ address: userAddr })
    });
    if (!res.ok) throw new Error(await res.text());
    const data = await res.json();
    log(`‚úÖ Faucet enviado!\nTx: ${data.tx_hash}\nTo: ${data.to}\nAmount: 10 AIC`, "ok");
  } catch (e) {
    log("Error faucet: " + (e.message || e), "err");
  }
};


    enableButtons(false, false, false, false);
  })();
  </script>
</body>
</html>
